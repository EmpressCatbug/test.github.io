<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Smart Thermostat Project | Takeria Thompson</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css" />
  <style>
    .project-page {
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    .project-page h1 {
      font-size: 2.8rem;
      text-align: center;
      margin-bottom: 20px;
    }

    .project-page h2 {
      font-size: 2rem;
      margin-top: 50px;
      margin-bottom: 10px;
      color: #e9d5ff;
    }

    .project-page h3 {
      margin-top: 30px;
      font-size: 1.2rem;
      color: #c084fc;
    }

    .project-page p {
      font-size: 1.05rem;
      line-height: 1.7;
      margin-top: 10px;
      color: #ddd;
    }

    .project-diagram {
      display: block;
      margin: 30px auto;
      max-width: 100%;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(186, 127, 255, 0.3);
    }

    .video-container {
      display: flex;
      justify-content: center;
      margin-top: 30px;
    }

    .back-link {
      font-size: 0.95rem;
      margin-bottom: 20px;
      display: inline-block;
      color: #c084fc;
    }

    .back-link:hover {
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="sparkle-container"></div>
  <div class="project-page">
    <h1 class="glow">Smart Thermostat Project</h1>
    <a class="back-link" href="../index.html">← Back to Portfolio</a>

    <h2>Overview</h2>
    <p>
      This project demonstrates a smart thermostat system built on the Texas Instruments CC3220x LaunchPad, a microcontroller commonly used in embedded systems. 
      Embedded systems are small, dedicated computers integrated into larger devices — like thermostats, medical devices, or even space probes — where they control specific functions in real-time.
    </p>
    
    <p>
      The thermostat monitors ambient temperature, allows user input via physical buttons, and controls an LED to simulate a heating element's status. It also mimics data reporting to a server, just like how smart home devices share data with a mobile app or cloud platform.
    </p>
    
    <p>
      Several hardware communication protocols were used to bring this system together:
      <strong>I2C (Inter-Integrated Circuit)</strong> was used to communicate with a digital temperature sensor — think of it like a short-range conversation between two components on the same circuit board.
      <strong>UART (Universal Asynchronous Receiver/Transmitter)</strong> enabled data to be sent to a virtual server, similar to how your computer communicates with a USB device.
      <strong>GPIO (General Purpose Input/Output)</strong> was used to detect when buttons were pressed by the user.
    </p>
    
    <p>
      Together, these elements form a responsive, modular system that could serve as the foundation for more advanced smart home technologies. This project emphasizes clean architecture, hardware integration, and real-time feedback — core principles in embedded software engineering.
    </p>    

    <h2>Task Scheduler</h2>
<p>
  At the heart of the smart thermostat system is a task scheduler — a logical structure that determines the order and timing of each system action.
  In embedded systems like this one, we can’t rely on large operating systems to manage tasks in the background, so we build our own simple scheduler
  to make sure each component runs in the right order, at the right time.
</p>

<p>
  The diagram below illustrates the main control flow of the thermostat:
</p>

<img src="images/TaskScheduler.drawio.png" alt="Task Scheduler Diagram" class="project-diagram" />

<p>
  The cycle begins with <strong>System Initialization</strong>, where hardware peripherals like sensors, timers, and communication interfaces are configured.
  Once the system is ready, it proceeds to <strong>Read Temperature via I2C</strong>, which retrieves real-time temperature data from a digital sensor.
</p>

<p>
  Next, the program checks for user input in <strong>Check Button States via GPIO</strong>. These physical buttons allow users to raise or lower the target temperature.
  The <strong>Control LED</strong> step compares the current room temperature with the setpoint and updates the LED status accordingly — for example, turning the light on if the room is too cold.
</p>

<p>
  After that, the system enters the <strong>Send Data via UART</strong> stage. Here, simulated data is packaged and sent out as if reporting to a remote server.
  This step mimics how smart devices communicate with cloud platforms or mobile apps in real-world IoT systems.
</p>

<p>
  Finally, a <strong>Timer Event Trigger</strong> introduces a short delay or interval before the scheduler reaches the <strong>End of Cycle</strong>, where it loops back and starts again.
  This continuous loop ensures the system stays responsive and up to date, monitoring and reacting to new temperature readings and user actions in real time.
</p>

<p>
  This modular, loop-based approach is a common practice in embedded systems, and designing it from scratch helped reinforce core concepts like system timing, I/O coordination, and real-time responsiveness.
</p>


    <h2>Source Code</h2>
    <p>
      The code includes I2C temperature sensing, GPIO for button inputs, and UART communication.
      It’s modular, documented, and designed for future adaptability.
    </p>

    <h2>Video Demonstration</h2>
    <p>
      A demo video showcases the live functionality: temperature sensing, LED response, and button control.
    </p>
    <div class="video-container">
      <iframe width="560" height="315" src="https://www.youtube.com/embed/pM9mzez48oQ" 
        title="Smart Thermostat Demo" frameborder="0" allowfullscreen></iframe>
    </div>

    <h2>Reflection</h2>

    <h3>A. What did you do particularly well?</h3>
    <p>I excelled in implementing I2C and UART communication and integrating them into a clean scheduler.</p>

    <h3>B. Where could you improve?</h3>
    <p>The task scheduler can be optimized for performance, and error handling can be improved for robustness.</p>

    <h3>C. What tools and resources did you add to your support network?</h3>
    <p>TI’s Code Composer Studio, draw.io, and TI’s developer forums were instrumental in debugging and design.</p>

    <h3>D. Transferable Skills</h3>
    <p>
      Embedded interface programming (I2C, GPIO, UART), hardware debugging, modular coding — all very applicable to future projects.
    </p>

    <h3>E. Maintainability & Adaptability</h3>
    <p>
      My code structure uses clear naming, modular functions, and in-line documentation, which makes adding new sensors or features easy.
    </p>

    <h2>Conclusion</h2>
    <p>
      This project solidified my understanding of embedded hardware, communication protocols, and system architecture.
      It’s an experience I’ll carry into every future engineering challenge.
    </p>
  </div>
  <script src="../script.js"></script>
</body>
</html>
